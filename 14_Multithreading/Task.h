#pragma once
/*
    Реализуйте шаблонный класс

    template<typename T>
    class BoundedBuffer {
    public:
      explicit BoundedBuffer(size_t capacity);

      // положить элемент в буфер; блокирует, если буфер полон
      void push(const T& item);

      // взять элемент из буфера; блокирует, если буфер пуст
      T pop();

    private:
      // ваш выбор: std::queue<T> или std::deque<T>
      // + std::mutex, std::condition_variable для ожидания
    };

    В main():

    Создайте BoundedBuffer<int> ёмкостью N = 5.

    Запустите 2 производителя и 3 потребителя:

    Каждый производитель генерирует по 20 целых чисел (например, от 1 до 20), вызывает push(), затем выходит.

    Каждый потребитель в цикле вызывает pop() и печатает полученное число и свой идентификатор до тех пор,
    пока не обработает все 40 чисел (общий объём от обоих производителей).

Убедитесь, что:
    Производители блокируются, когда буфер полон.
    Потребители блокируются, когда буфер пуст.
    Все 40 чисел корректно напечатаны (порядок интерливинг, но без потерь).

    Подсказка, решение можно оформить через std::conditional_variables. Вам нужно отдельно почитать про них :)
*/


int main() {}